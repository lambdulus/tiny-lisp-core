import { LexerToken } from "../lexer/LexerTokens";
import { Lexer } from "../lexer/Lexer";
import { Instruction } from "../utility/instructions/Instruction";
import { SymbTable } from "./SymbTable";
import { SECDArray } from "../utility/SECD/SECDArray";
import { InstructionShortcut } from "../utility/instructions/InstructionShortcut";
import { CompositeNode, InnerNode, TopNode } from "../AST/AST";
import { SECDElement } from "../utility/SECD/SECDElement";
export declare class Parser {
    get topNode(): TopNode | null;
    symbTable: SymbTable;
    quoted: boolean;
    isMacro: boolean;
    macros: Array<string>;
    lexer: Lexer;
    currTok: LexerToken | null;
    isMainCode: boolean;
    private _topNode;
    constructor(mainCode?: boolean);
    protected compare(tok: LexerToken): void;
    protected push(arr: SECDArray, val: string | number | Instruction | SECDArray): number;
    parse(input: string, args?: SymbTable): SECDArray;
    protected loadInstructions(): SECDArray;
    protected topLevel(): [SECDArray, InnerNode];
    protected definition(): [SECDArray, InnerNode];
    protected expr(isMacroCall?: boolean): SECDArray;
    protected expr_body(): SECDArray;
    protected val(): SECDArray;
    protected iden(): SECDArray;
    protected args(): string[];
    protected letBody(): [string[], SECDArray];
    protected beginBody(): SECDArray;
    protected functionCall(): SECDArray;
    protected functionArgs(isMacroCall: boolean): SECDArray;
    protected str(): SECDArray;
    protected num(): SECDArray;
    protected lambda(args: CompositeNode, isCall?: number): SECDArray;
    protected compileUnaryOperator(instructionShortcut: InstructionShortcut): SECDArray;
    protected compileBinaryOperator(instructionShortcut: InstructionShortcut): SECDArray;
    protected compileQuote(): SECDArray;
    protected compileComma(): SECDArray;
    private getOperator;
    private compileMacro;
    protected createNode(element: SECDElement): InnerNode;
}
